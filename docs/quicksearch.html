<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"client.js.html":{"id":"client.js.html","title":"Source: client.js","body":" MQ Nodejs HTTP SDK Documents Classes MessagePropertiesMQClientMQConsumerMQProducerMQTransProducer Source: client.js 'use strict'; const assert = require('assert'); const EventEmitter = require('events'); const debug = require('debug')('mq:client'); const httpx = require('httpx'); const kitx = require('kitx'); require('dnscache')({ enable : true, ttl : 300, cachesize : 1000 }); const { toXMLBuffer, parseXML, extract, getCanonicalizedMQHeaders } = require('./helper'); /** * MQ的client,用于保存aliyun账号消息,以及发送http请求 */ class MQClient { /** * MQClient构造函数 * @param {string} endpoint MQ的HTTP接入地址 * @param {string} accessKeyId 阿里云账号的AK * @param {string} accessKeySecret 阿里云账号的SK * @param {string} securityToken 阿里云RAM授权的STS TOKEN，可空 * * @returns {MQClient} */ constructor(endpoint, accessKeyId, accessKeySecret, securityToken, options) { assert(endpoint, '\"endpoint\" must be passed in'); this.endpoint = endpoint; assert(accessKeyId, 'must pass in \"accessKeyId\"'); this.accessKeyId = accessKeyId; assert(accessKeySecret, 'must pass in \"accessKeySecret\"'); this.accessKeySecret = accessKeySecret; // security token this.securityToken = securityToken; this.options = Object.assign({ pullInterval: 3000, // 长轮询时间，不填则为短轮询，取值范围：1～30s，单位：毫秒。 pullBatchSize: 16, // 一次最多拉取多少条消息，取值范围：1～16。 pullTimeDelayMillsWhenFlowControl: 3000, // 进入流控逻辑，延迟一段时间再拉 pullThresholdForQueue: 100, // 本地队列消息数超过此阀值，开始流控 }, options) } /** * 发送http请求 * @param {string} method HTTP的请求方法GET/PUT/POST/DELETE... * @param {string} resource HTTP请求URL的path * @param {string} type 解析XML响应内容的元素名字 * @param {string} requestBody 请求的body * @param {object} opts 额外请求的参数 * * @returns {object} * ```json * { * code: 200, * requestId: \"xxxxxxxxxxxxxx\", * body: {A:1,B:2,C:3} * } * ```json */ async request(method, resource, type, requestBody, opts = {}) { const url = `${this.endpoint}${resource}`; debug('url: %s', url); debug('method: %s', method); const headers = this.buildHeaders(method, requestBody, resource, opts.headers); debug('request headers: %j', headers); debug('request body: %s', requestBody.toString()); const response = await httpx.request(url, Object.assign(opts, { method: method, headers: headers, data: requestBody })); debug('statusCode %s', response.statusCode); debug('response headers: %j', response.headers); const code = response.statusCode; const contentType = response.headers['content-type'] || ''; const responseBody = await httpx.read(response, 'utf8'); debug('response body: %s', responseBody); var body; if (responseBody &amp;&amp; (contentType.startsWith('text/xml') || contentType.startsWith('application/xml'))) { const responseData = await parseXML(responseBody); if (responseData.Error) { const e = responseData.Error; const message = extract(e.Message); const requestid = extract(e.RequestId); // const hostid = extract(e.HostId); const errorcode = extract(e.Code); const err = new Error(`${method} ${url} failed with ${code}. ` + `RequestId: ${requestid}, ErrorCode: ${errorcode}, ErrorMsg: ${message}`); err.Code = errorcode; err.RequestId = requestid; throw err; } body = {}; Object.keys(responseData[type]).forEach(key =&gt; { if (key !== '$') { body[key] = extract(responseData[type][key]); } }); } return { code, requestId: response.headers['x-mq-request-id'], body, }; } /** * 发送HTTP GET请求 * * @param {string} resource HTTP请求URL的path * @param {string} type 解析XML响应内容的元素名字 * @param {object} opts 额外请求的参数 * * @returns {object} * ```json * { * code: 200, * requestId: \"xxxxxxxxxxxxxx\", * body: {A:1,B:2,C:3} * } * ``` */ get(resource, type, opts) { return this.request('GET', resource, type, '', opts); } /** * 发送HTTP POST请求 * * @param {string} resource HTTP请求URL的path * @param {string} type 解析XML响应内容的元素名字 * @param {string} requestBody 请求的body * @returns {object} * ```json * { * code: 200, * requestId: \"xxxxxxxxxxxxxx\", * body: {A:1,B:2,C:3} * } * ``` */ post(resource, type, body) { return this.request('POST', resource, type, body); } /** * 发送HTTP DELETE请求 * * @param {string} resource HTTP请求URL的path * @param {string} type 解析XML响应内容的元素名字 * @param {string} requestBody 请求的body * @returns {object} * ```json * { * code: 200, * requestId: \"xxxxxxxxxxxxxx\", * body: {A:1,B:2,C:3} * } * ``` */ delete(resource, type, body) { return this.request('DELETE', resource, type, body); } /** * 对请求的内容按照MQ的HTTP协议签名,sha1+base64 * @param {string} method 请求方法 * @param {object} headers 请求头 * @param {string} resource HTTP请求URL的path * * @returns {string} 签名 */ sign(method, headers, resource) { const canonicalizedMQHeaders = getCanonicalizedMQHeaders(headers); const md5 = headers['content-md5'] || ''; const date = headers['date']; const type = headers['content-type'] || ''; var toSignString = `${method}\\n${md5}\\n${type}\\n${date}\\n${canonicalizedMQHeaders}${resource}`; var buff = Buffer.from(toSignString, 'utf8'); const degist = kitx.sha1(buff, this.accessKeySecret, 'binary'); return Buffer.from(degist, 'binary').toString('base64'); } /** * 组装请求MQ需要的请求头 * @param {string} method 请求方法 * @param {string} body 请求内容 * @param {string} resource HTTP请求URL的path * * @returns {object} headers */ buildHeaders(method, body, resource) { const date = new Date().toGMTString(); const headers = { 'date': date, 'x-mq-version': '2015-06-06', 'content-type': 'text/xml;charset=utf-8', 'user-agent': 'mq-nodejs-sdk/1.0.0' }; if (method !== 'GET' &amp;&amp; method !== 'HEAD') { const digest = kitx.md5(body, 'hex'); const md5 = Buffer.from(digest, 'utf8').toString('base64'); Object.assign(headers, { 'content-length': body.length, 'content-md5': md5 }); } const signature = this.sign(method, headers, resource); headers['authorization'] = `MQ ${this.accessKeyId}:${signature}`; if (this.securityToken) { headers['security-token'] = this.securityToken; } return headers; } /** * 构造一个MQ的消费者 * @param {string} instanceId 实例ID * @param {string} topic 主题名字 * @param {string} consumer 消费者名字 * @param {string} messageTag 消费的过滤标签，可空 * * @returns {MQConsumer} */ getConsumer(instanceId, topic, consumer, messageTag) { // eslint-disable-next-line no-use-before-define return new MQConsumer(this, instanceId, topic, consumer, messageTag); } /** * 构造一个MQ的生产者 * @param {string} instanceId 实例ID * @param {string} topic 主题名字 * * @returns {MQProducer} */ getProducer(instanceId, topic) { // eslint-disable-next-line no-use-before-define return new MQProducer(this, instanceId, topic); } /** * 构造一个MQ的事务消息生产者 * @param {string} instanceId 实例ID * @param {string} topic 主题名字 * @param {string} groupId 客户端GroupID * * @returns {MQTransProducer} */ getTransProducer(instanceId, topic, groupId) { // eslint-disable-next-line no-use-before-define return new MQTransProducer(this, instanceId, topic, groupId); } } /** * 消息属性 */ class MessageProperties { constructor({ startDeliverTime, transCheckImmunityTime, properties } = {}) { this.properties = {}; if (startDeliverTime) { this.startDeliverTime(startDeliverTime); } if (transCheckImmunityTime) { this.transCheckImmunityTime(transCheckImmunityTime); } if (properties) { Object.entries(properties).forEach(([ key, value ]) =&gt; { this.putProperty(key, value); }); } } /** * 获取消息属性内部的Object * * @returns {Object} */ getProperties() { return this.properties; } /** * 设置消息KEY * @param {string} key 消息KEY */ messageKey(key) { if (key == null) { return; } this.properties[\"KEYS\"] = key + \"\"; } /** * 定时消息，单位毫秒（ms），在指定时间戳（当前时间之后）进行投递。 * 如果被设置成当前时间戳之前的某个时刻，消息将立刻投递给消费者 * * @param {Number} timeMillis 定时的绝对时间戳 */ startDeliverTime(timeMillis) { if (timeMillis == null) { return; } this.properties[\"__STARTDELIVERTIME\"] = timeMillis + \"\"; } /** * 在消息属性中添加第一次消息回查的最快时间，单位秒，并且表征这是一条事务消息 * * @param {Number} timeSeconds 第一次消息回查时间，单位秒 */ transCheckImmunityTime(timeSeconds) { if (timeSeconds == null) { return; } this.properties[\"__TransCheckT\"] = timeSeconds + \"\"; } /** * 设置消息自定义属性 * * @param {string} key 属性键,非空 * @param {string} value 属性值,非空 */ putProperty(key, value) { if (key == null || value == null) { return; } const keyStr = key + \"\"; const valueStr = value + \"\"; if (keyStr != \"\" &amp;&amp; valueStr != \"\") { this.check(keyStr); this.check(valueStr); this.properties[keyStr] = valueStr; } } check(key) { if (key.indexOf('\\'') &gt; -1 || key.indexOf('\"') &gt; -1 || key.indexOf('&amp;') &gt; -1 || key.indexOf('&lt;') &gt; -1 || key.indexOf('&gt;') &gt; -1 || key.indexOf('|') &gt; -1 || key.indexOf(':') &gt; -1) { throw new Error(`Property ${key} can not contains: \\\" \\' &amp; &lt; &gt; | :`); } } } /** * MQ的消息生产者 */ class MQProducer { /** * 构造函数 * @param {MQClient} client MQ的客户端 * @param {string} instanceId 实例ID * @param {string} topic 主题名字 * * @returns {MQProducer} */ constructor(client, instanceId, topic) { assert(client, '\"client\" must be passed in'); assert(topic, '\"topic\" must be passed in'); this.client = client; this.instanceId = instanceId; this.topic = topic; if (instanceId &amp;&amp; instanceId !== '') { this.path = `/topics/${topic}/messages?ns=${instanceId}`; } else { this.path = `/topics/${topic}/messages`; } } /** * 向主题发送一条消息 * @param {string} body 发送的内容 * @param {string} tag 发送消息的标签 * @param {MessageProperties} msgProps 发送消息的属性 * * @returns {object} * ```json * { * // http请求状态码，发送成功就是201，如果发送失败则抛异常 * code: 201, * // 请求ID * requestId: \"xxxxxxxxxxxxxx\", * // 发送消息的响应内容 * body: { * // 消息ID * MessageId: \"\", * // 消息体内容的MD5值 * MessageBodyMD5: \"\" * } * } * ``` * @throws {exception} err MQ服务端返回的错误或者其它网络异常 * ```json * { * // MQ服务端返回的错误Code，like: TopicNotExist * Code:\"\", * // 请求ID * RequestId:\"\" * } * ``` */ async publishMessage(body, tag, msgProps) { var xmlBody; var params = {MessageBody: body}; if (tag &amp;&amp; tag != '') { params.MessageTag = tag; } if (msgProps) { var props = msgProps.getProperties(); var propKeys = Object.keys(props); if (propKeys.length &gt; 0) { params.Properties = propKeys .map((key) =&gt; `${key}:${props[key]}`).join('|'); } } var response = this.client.post(this.path, 'Message', toXMLBuffer('Message', params)); return response; } async sendMsg(msg, tag, msgProps) { const ret = await this.publishMessage(msg, tag, msgProps &amp;&amp; new MessageProperties(msgProps)); assert(ret.code === 201); return { msgId: ret.body.MessageId, msgBodyMd5: ret.body.MessageBodyMD5, }; } } /** * MQ的消息生产者，支持事务 */ class MQTransProducer { /** * 构造函数 * @param {MQClient} client MQ的客户端 * @param {string} instanceId 实例ID * @param {string} topic 主题名字 * @param {string} groupId 客户端GroupID * * @returns {MQTransProducer} */ constructor(client, instanceId, topic, groupId) { assert(client, '\"client\" must be passed in'); assert(topic, '\"topic\" must be passed in'); assert(groupId, '\"groupId\" must be passed in'); this.client = client; this.instanceId = instanceId; this.topic = topic; this.groupId = groupId; if (instanceId &amp;&amp; instanceId !== '') { this.path = `/topics/${topic}/messages?ns=${instanceId}`; this.transPopPath = `/topics/${topic}/messages?consumer=${groupId}&amp;ns=${instanceId}&amp;trans=pop`; this.transOprPath= `/topics/${topic}/messages?consumer=${groupId}&amp;ns=${instanceId}`; } else { this.path = `/topics/${topic}/messages`; this.transPopPath = `/topics/${topic}/messages?consumer=${groupId}&amp;trans=pop`; this.transOprPath= `/topics/${topic}/messages?consumer=${groupId}`; } } /** * 向主题发送一条消息 * @param {string} body 发送的内容 * @param {string} tag 发送消息的标签 * @param {MessageProperties} msgProps 发送消息的属性 * * @returns {object} * ```json * { * // http请求状态码，发送成功就是201，如果发送失败则抛异常 * code: 201, * // 请求ID * requestId: \"xxxxxxxxxxxxxx\", * // 发送消息的响应内容 * body: { * // 消息ID * MessageId: \"\", * // 消息体内容的MD5值 * MessageBodyMD5: \"\" * // 消息句柄，仅事务消息存在 * ReceiptHandle: \"\" * } * } * ``` * @throws {exception} err MQ服务端返回的错误或者其它网络异常 * ```json * { * // MQ服务端返回的错误Code，like: TopicNotExist * Code:\"\", * // 请求ID * RequestId:\"\" * } * ``` */ async publishMessage(body, tag, msgProps) { var xmlBody; var params = {MessageBody: body}; if (tag &amp;&amp; tag != '') { params.MessageTag = tag; } if (msgProps) { var props = msgProps.getProperties(); var propKeys = Object.keys(props); if (propKeys.length &gt; 0) { params.Properties = propKeys .map((key) =&gt; `${key}:${props[key]}`).join('|'); } } var response = this.client.post(this.path, 'Message', toXMLBuffer('Message', params)); return response; } /** * 消费检查事务半消息,默认如果该条消息没有被 {commit} 或者 {rollback} 在NextConsumeTime时会再次消费到该条消息 * * @param {int} numOfMessages 每次从服务端消费条消息 * @param {int} waitSeconds 长轮询的等待时间（可空），如果服务端没有消息请求会在该时间之后返回等于请求阻塞在服务端，如果期间有消息立刻返回 * * @returns {object} * ```json * { * code: 200, * requestId: \"\", * body: [ * { * // 消息ID * MessageId: \"\", * // 消息体MD5 * MessageBodyMD5: \"\", * // 发送消息的时间戳，毫秒 * PublishTime: {long}, * // 下次重试消费的时间，前提是这次不调用{commit} 或者 {rollback}，毫秒 * NextConsumeTime: {long}, * // 第一次消费的时间，毫秒 * FirstConsumeTime: {long}, * // 消费的次数 * ConsumedTimes: {long}, * // 消息句柄，调用 {commit} 或者 {rollback} 需要将消息句柄传入，用于提交或者回滚该条事务消息 * ReceiptHandle: \"\", * // 消息内容 * MessageBody: \"\", * // 消息标签 * MessageTag: \"\" * } * ] * } * * ``` * @throws {exception} err MQ服务端返回的错误或者其它网络异常 * ```json * { * // MQ服务端返回的错误Code，其中MessageNotExist是正常现象，表示没有可消费的消息 * Code: \"\", * // 请求ID * RequestId: \"\" * } * ```json */ async consumeHalfMessage(numOfMessages, waitSeconds) { var url = this.transPopPath + `&amp;numOfMessages=${numOfMessages}`; if (waitSeconds) { url += `&amp;waitseconds=${waitSeconds}`; } const subType = 'Message'; var response = await this.client.get(url, 'Messages', {timeout: 33000}); response.body = response.body[subType]; response.body.forEach((msg) =&gt; { var props = {}; if (msg.Properties) { var props = {}; var kvArray = msg.Properties.split('|'); for (var i=0; i &lt; kvArray.length; i++) { if (kvArray[i] == '') { continue; } var kAndV = kvArray[i].split(':'); if (kAndV.length != 2 || kAndV[0] == '' || kAndV[1] == '') { continue; } props[kAndV[0]] = kAndV[1]; } if (props['KEYS']) { msg.MessageKey = props['KEYS']; delete props['KEYS']; } if (props['__STARTDELIVERTIME']) { msg.StartDeliverTime = parseInt(props['__STARTDELIVERTIME']); delete props['__STARTDELIVERTIME']; } if (props['__TransCheckT']) { msg.StartDeliverTime = parseInt(props['__TransCheckT']); delete props['__TransCheckT']; } } msg.Properties = props; }); return response; } /** * 提交事务消息 * * @param {string} receiptHandle consumeHalfMessage返回的单条消息句柄或者是发送事务消息返回的句柄 * * @returns {object} * ```json * { * // 请求成功 * code:204, * // 请求ID * requestId:\"\" * } * ``` * * @throws {exception} err 请求失败或者其它网络异常 * ```json * { * // MQ服务端返回的错误Code，如ReceiptHandleError，表示消息句柄非法，MessageNotExist如果超过了TransCheckImmunityTime（针对发送事务消息的句柄）或者超过NextCnosumeTime * Code: \"\" * // 请求ID * RequestId: \"\" * } * ``` */ async commit(receiptHandle) { const body = toXMLBuffer('ReceiptHandles', [receiptHandle], 'ReceiptHandle'); const response = await this.client.delete(this.transOprPath + '&amp;trans=commit', 'Errors', body); // 3种情况，普通失败，部分失败，全部成功 if (response.body) { const subType = 'Error'; // 部分失败 response.body = response.body[subType]; } return response; } /** * 回滚事务消息 * * @param {string} receiptHandle consumeHalfMessage返回的单条消息句柄或者是发送事务消息返回的句柄 * * @returns {object} * ```json * { * // 请求成功 * code:204, * // 请求ID * requestId:\"\" * } * ``` * * @throws {exception} err 请求失败或者其它网络异常 * ```json * { * // MQ服务端返回的错误Code，如ReceiptHandleError，表示消息句柄非法，MessageNotExist如果超过了TransCheckImmunityTime（针对发送事务消息的句柄）或者超过NextCnosumeTime * Code: \"\" * // 请求ID * RequestId: \"\" * } * ``` */ async rollback(receiptHandle) { const body = toXMLBuffer('ReceiptHandles', [receiptHandle], 'ReceiptHandle'); const response = await this.client.delete(this.transOprPath + '&amp;trans=rollback', 'Errors', body); // 3种情况，普通失败，部分失败，全部成功 if (response.body) { const subType = 'Error'; // 部分失败 response.body = response.body[subType]; } return response; } } /** * MQ的消息消费者 */ class MQConsumer extends EventEmitter { /** * 消费者构造函数 * @param {MQClient} client MQ客户端 * @param {string} instanceId 实例ID * @param {string} topic 主题名字 * @param {string} consumer 消费者名字(CID)a * @param {string} messageTag 消费消息的过滤标签，可空 * * @returns {MQConsumer} */ constructor(client, instanceId, topic, consumer, messageTag) { super(); assert(client, '\"client\" must be passed in'); assert(topic, '\"topic\" must be passed in'); assert(consumer, '\"consumer\" must be passed in'); this.client = client; this.instanceId = instanceId; this.topic = topic; this.consumer = consumer; this.messageTag = messageTag; if (instanceId &amp;&amp; instanceId !== '') { if (messageTag) { this.path = `/topics/${topic}/messages?consumer=${consumer}&amp;ns=${instanceId}&amp;tag=${messageTag}`; } else { this.path = `/topics/${topic}/messages?consumer=${consumer}&amp;ns=${instanceId}`; } this.ackPath = `/topics/${topic}/messages?consumer=${consumer}&amp;ns=${instanceId}`; } else { if (messageTag) { this.path = `/topics/${topic}/messages?consumer=${consumer}&amp;tag=${messageTag}`; } else { this.path = `/topics/${topic}/messages?consumer=${consumer}`; } this.ackPath = `/topics/${topic}/messages?consumer=${consumer}`; } } /** * 消费消息,默认如果该条消息没有被 {ackMessage} 确认消费成功，即在NextConsumeTime时会再次消费到该条消息 * * @param {int} numOfMessages 每次从服务端消费条消息 * @param {int} waitSeconds 长轮询的等待时间（可空），如果服务端没有消息请求会在该时间之后返回等于请求阻塞在服务端，如果期间有消息立刻返回 * * @returns {object} * ```json * { * code: 200, * requestId: \"\", * body: [ * { * // 消息ID * MessageId: \"\", * // 消息体MD5 * MessageBodyMD5: \"\", * // 发送消息的时间戳，毫秒 * PublishTime: {long}, * // 下次重试消费的时间，前提是这次不调用{ackMessage} 确认消费消费成功，毫秒 * NextConsumeTime: {long}, * // 第一次消费的时间，毫秒 * FirstConsumeTime: {long}, * // 消费的次数 * ConsumedTimes: {long}, * // 消息句柄，调用 {ackMessage} 需要将消息句柄传入，用于确认该条消息消费成功 * ReceiptHandle: \"\", * // 消息内容 * MessageBody: \"\", * // 消息标签 * MessageTag: \"\" * } * ] * } * * ``` * @throws {exception} err MQ服务端返回的错误或者其它网络异常 * ```json * { * // MQ服务端返回的错误Code，其中MessageNotExist是正常现象，表示没有可消费的消息 * Code: \"\", * // 请求ID * RequestId: \"\" * } * ```json */ async consumeMessage(numOfMessages, waitSeconds) { var url = this.path + `&amp;numOfMessages=${numOfMessages}`; if (waitSeconds) { url += `&amp;waitseconds=${waitSeconds}`; } const subType = 'Message'; var response = await this.client.get(url, 'Messages', {timeout: 33000}); response.body = response.body[subType]; response.body.forEach((msg) =&gt; { var props = {}; if (msg.Properties) { var props = {}; var kvArray = msg.Properties.split('|'); for (var i=0; i &lt; kvArray.length; i++) { if (kvArray[i] == '') { continue; } var kAndV = kvArray[i].split(':'); if (kAndV.length != 2 || kAndV[0] == '' || kAndV[1] == '') { continue; } props[kAndV[0]] = kAndV[1]; } if (props['KEYS']) { msg.MessageKey = props['KEYS']; delete props['KEYS']; } if (props['__STARTDELIVERTIME']) { msg.StartDeliverTime = parseInt(props['__STARTDELIVERTIME']); delete props['__STARTDELIVERTIME']; } if (props['__TransCheckT']) { msg.StartDeliverTime = parseInt(props['__TransCheckT']); delete props['__TransCheckT']; } } msg.Properties = props; }); return response; } /** * 确认消息消费成功，消费成功后需要调用该接口否则会重复消费消息 * * @param {array} receiptHandles 消息句柄数组 * * @returns {object} * ```json * { * // 请求成功 * code:204, * // 请求ID * requestId:\"\" * } * ``` * * @throws {exception} err 请求失败或者其它网络异常 * ```json * { * // MQ服务端返回的错误Code，如ReceiptHandleError，表示消息句柄非法，MessageNotExist表示超过了ack的时间，即NextConsumeTime * Code: \"\" * // 请求ID * RequestId: \"\" * } * ``` */ async ackMessage(receiptHandles) { const body = toXMLBuffer('ReceiptHandles', receiptHandles, 'ReceiptHandle'); const response = await this.client.delete(this.ackPath, 'Errors', body); // 3种情况，普通失败，部分失败，全部成功 if (response.body) { const subType = 'Error'; // 部分失败 response.body = response.body[subType]; } return response; } async subscribe(onMsg, options = {}) { assert(onMsg, 'required onMsg'); this._pendingCount = 0 const { pullThresholdForQueue, pullTimeDelayMillsWhenFlowControl, pullBatchSize, pullInterval, } = { ...this.client.options, ...options }; const waitSeconds = Math.floor(pullInterval / 1000); this._startedAt = Date.now(); while (this._startedAt) { const freeCount = pullThresholdForQueue - this._pendingCount; if (freeCount &lt;= 0) { await sleep(pullTimeDelayMillsWhenFlowControl); continue; } const checkedPullBatchSize = freeCount &lt; pullBatchSize ? freeCount : pullBatchSize; // 一次最多消费3条(最多可设置为16条) try { const msgsRet = await this.consumeMessage( checkedPullBatchSize, Math.floor(pullInterval / 1000) // 长轮询时间3秒（最多可设置为30秒） ); if (msgsRet.code === 200) { msgsRet.body.map(async message =&gt; { this._pendingCount += 1; try { await onMsg(message.MessageBody, message); try { // message.NextConsumeTime(5 min)前若不确认消息消费成功，则消息会重复消费 const ackRet = await this.ackMessage([ message.ReceiptHandle ]); if (ackRet.code !== 204) { // 这会导致重复消费, 业务层需要去重 this.emit('ackFailed', message); console.error('Ack Message Fail:', res); } } catch (err) { this.emit('ackFailed', message); console.error('Ack Message Fail:', err); } } catch (err) { console.error(err); } this._pendingCount -= 1; if (this._pendingCount === 0) { this.emit('done'); } }); } else { console.error(msgsRet); } } catch (err) { if (!err.Code || !err.Code.includes('MessageNotExist')) { console.error(err); } } } } async safeClose() { this._startedAt = 0; return new Promise(resolve =&gt; { process.nextTick(() =&gt; { if (this._pendingCount === 0) { return resolve(); } this.once('done', resolve); }); }); } } module.exports = { MQClient, MQConsumer, MQProducer, MessageProperties }; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" MQ Nodejs HTTP SDK Documents Classes MessagePropertiesMQClientMQConsumerMQProducerMQTransProducer Classes Classes MessageProperties MQClient MQConsumer MQProducer MQTransProducer × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" MQ Nodejs HTTP SDK Documents Classes MessagePropertiesMQClientMQConsumerMQProducerMQTransProducer MQ Nodejs HTTP SDK Alyun MQ Documents: http://www.aliyun.com/product/ons Aliyun MQ Console: https://ons.console.aliyun.com Installation Add dependency @aliyunmq/mq-http-sdk, get the latest version from npmjs npm install --save Note: nodejs &gt;= 7.6.0 docs Documents Sample V1.0.1 Samples Publish Message Consume Message V1.0.2 Samples Publish Message Consume Message Transaction Message Note for 1.0.2: Http consumer only support timer msg(less than 3 days), no matter the msg is produced from http or tcp protocal. × Search results Close "},"MessageProperties.html":{"id":"MessageProperties.html","title":"Class: MessageProperties","body":" MQ Nodejs HTTP SDK Documents Classes MessagePropertiesMQClientMQConsumerMQProducerMQTransProducer Class: MessageProperties MessageProperties 消息属性 new MessageProperties() Source: client.js, line 284 Methods getProperties() 获取消息属性内部的Object Source: client.js, line 304 Returns: Type Object messageKey(key) 设置消息KEY Parameters: Name Type Description key string 消息KEY Source: client.js, line 312 putProperty(key, value) 设置消息自定义属性 Parameters: Name Type Description key string 属性键,非空 value string 属性值,非空 Source: client.js, line 350 startDeliverTime(timeMillis) 定时消息，单位毫秒（ms），在指定时间戳（当前时间之后）进行投递。 如果被设置成当前时间戳之前的某个时刻，消息将立刻投递给消费者 Parameters: Name Type Description timeMillis Number 定时的绝对时间戳 Source: client.js, line 325 transCheckImmunityTime(timeSeconds) 在消息属性中添加第一次消息回查的最快时间，单位秒，并且表征这是一条事务消息 Parameters: Name Type Description timeSeconds Number 第一次消息回查时间，单位秒 Source: client.js, line 337 × Search results Close "},"MQClient.html":{"id":"MQClient.html","title":"Class: MQClient","body":" MQ Nodejs HTTP SDK Documents Classes MessagePropertiesMQClientMQConsumerMQProducerMQTransProducer Class: MQClient MQClient MQ的client,用于保存aliyun账号消息,以及发送http请求 new MQClient(endpoint, accessKeyId, accessKeySecret, securityToken) MQClient构造函数 Parameters: Name Type Description endpoint string MQ的HTTP接入地址 accessKeyId string 阿里云账号的AK accessKeySecret string 阿里云账号的SK securityToken string 阿里云RAM授权的STS TOKEN，可空 Source: client.js, line 36 Returns: Type MQClient Methods buildHeaders(method, body, resource) 组装请求MQ需要的请求头 Parameters: Name Type Description method string 请求方法 body string 请求内容 resource string HTTP请求URL的path Source: client.js, line 209 Returns: headers Type object delete(resource, type, requestBody) 发送HTTP DELETE请求 Parameters: Name Type Description resource string HTTP请求URL的path type string 解析XML响应内容的元素名字 requestBody string 请求的body Source: client.js, line 177 Returns: { code: 200, requestId: \"xxxxxxxxxxxxxx\", body: {A:1,B:2,C:3} } Type object get(resource, type, opts) 发送HTTP GET请求 Parameters: Name Type Description resource string HTTP请求URL的path type string 解析XML响应内容的元素名字 opts object 额外请求的参数 Source: client.js, line 139 Returns: { code: 200, requestId: \"xxxxxxxxxxxxxx\", body: {A:1,B:2,C:3} } Type object getConsumer(instanceId, topic, consumer, messageTag) 构造一个MQ的消费者 Parameters: Name Type Description instanceId string 实例ID topic string 主题名字 consumer string 消费者名字 messageTag string 消费的过滤标签，可空 Source: client.js, line 248 Returns: Type MQConsumer getProducer(instanceId, topic) 构造一个MQ的生产者 Parameters: Name Type Description instanceId string 实例ID topic string 主题名字 Source: client.js, line 260 Returns: Type MQProducer getTransProducer(instanceId, topic, groupId) 构造一个MQ的事务消息生产者 Parameters: Name Type Description instanceId string 实例ID topic string 主题名字 groupId string 客户端GroupID Source: client.js, line 273 Returns: Type MQTransProducer post(resource, type, requestBody) 发送HTTP POST请求 Parameters: Name Type Description resource string HTTP请求URL的path type string 解析XML响应内容的元素名字 requestBody string 请求的body Source: client.js, line 158 Returns: { code: 200, requestId: \"xxxxxxxxxxxxxx\", body: {A:1,B:2,C:3} } Type object &lt;async&gt; request(method, resource, type, requestBody, opts) 发送http请求 Parameters: Name Type Description method string HTTP的请求方法GET/PUT/POST/DELETE... resource string HTTP请求URL的path type string 解析XML响应内容的元素名字 requestBody string 请求的body opts object 额外请求的参数 Source: client.js, line 70 Returns: { code: 200, requestId: \"xxxxxxxxxxxxxx\", body: {A:1,B:2,C:3} } ```json Type object sign(method, headers, resource) 对请求的内容按照MQ的HTTP协议签名,sha1+base64 Parameters: Name Type Description method string 请求方法 headers object 请求头 resource string HTTP请求URL的path Source: client.js, line 189 Returns: 签名 Type string × Search results Close "},"MQConsumer.html":{"id":"MQConsumer.html","title":"Class: MQConsumer","body":" MQ Nodejs HTTP SDK Documents Classes MessagePropertiesMQClientMQConsumerMQProducerMQTransProducer Class: MQConsumer MQConsumer MQ的消息消费者 new MQConsumer(client, instanceId, topic, consumer, messageTag) 消费者构造函数 Parameters: Name Type Description client MQClient MQ客户端 instanceId string 实例ID topic string 主题名字 consumer string 消费者名字(CID)a messageTag string 消费消息的过滤标签，可空 Source: client.js, line 723 Returns: Type MQConsumer Methods &lt;async&gt; ackMessage(receiptHandles) 确认消息消费成功，消费成功后需要调用该接口否则会重复消费消息 Parameters: Name Type Description receiptHandles array 消息句柄数组 Source: client.js, line 863 Throws: err 请求失败或者其它网络异常 { // MQ服务端返回的错误Code，如ReceiptHandleError，表示消息句柄非法，MessageNotExist表示超过了ack的时间，即NextConsumeTime Code: \"\" // 请求ID RequestId: \"\" } Type exception Returns: { // 请求成功 code:204, // 请求ID requestId:\"\" } Type object &lt;async&gt; consumeMessage(numOfMessages, waitSeconds) 消费消息,默认如果该条消息没有被 {ackMessage} 确认消费成功，即在NextConsumeTime时会再次消费到该条消息 Parameters: Name Type Description numOfMessages int 每次从服务端消费条消息 waitSeconds int 长轮询的等待时间（可空），如果服务端没有消息请求会在该时间之后返回等于请求阻塞在服务端，如果期间有消息立刻返回 Source: client.js, line 796 Throws: err MQ服务端返回的错误或者其它网络异常 { // MQ服务端返回的错误Code，其中MessageNotExist是正常现象，表示没有可消费的消息 Code: \"\", // 请求ID RequestId: \"\" } ```json Type exception Returns: { code: 200, requestId: \"\", body: [ { // 消息ID MessageId: \"\", // 消息体MD5 MessageBodyMD5: \"\", // 发送消息的时间戳，毫秒 PublishTime: {long}, // 下次重试消费的时间，前提是这次不调用{ackMessage} 确认消费消费成功，毫秒 NextConsumeTime: {long}, // 第一次消费的时间，毫秒 FirstConsumeTime: {long}, // 消费的次数 ConsumedTimes: {long}, // 消息句柄，调用 {ackMessage} 需要将消息句柄传入，用于确认该条消息消费成功 ReceiptHandle: \"\", // 消息内容 MessageBody: \"\", // 消息标签 MessageTag: \"\" } ] } Type object × Search results Close "},"MQProducer.html":{"id":"MQProducer.html","title":"Class: MQProducer","body":" MQ Nodejs HTTP SDK Documents Classes MessagePropertiesMQClientMQConsumerMQProducerMQTransProducer Class: MQProducer MQProducer MQ的消息生产者 new MQProducer(client, instanceId, topic) 构造函数 Parameters: Name Type Description client MQClient MQ的客户端 instanceId string 实例ID topic string 主题名字 Source: client.js, line 386 Returns: Type MQProducer Methods &lt;async&gt; publishMessage(body, tag, msgProps) 向主题发送一条消息 Parameters: Name Type Description body string 发送的内容 tag string 发送消息的标签 msgProps MessageProperties 发送消息的属性 Source: client.js, line 431 Throws: err MQ服务端返回的错误或者其它网络异常 { // MQ服务端返回的错误Code，like: TopicNotExist Code:\"\", // 请求ID RequestId:\"\" } Type exception Returns: { // http请求状态码，发送成功就是201，如果发送失败则抛异常 code: 201, // 请求ID requestId: \"xxxxxxxxxxxxxx\", // 发送消息的响应内容 body: { // 消息ID MessageId: \"\", // 消息体内容的MD5值 MessageBodyMD5: \"\" } } Type object × Search results Close "},"MQTransProducer.html":{"id":"MQTransProducer.html","title":"Class: MQTransProducer","body":" MQ Nodejs HTTP SDK Documents Classes MessagePropertiesMQClientMQConsumerMQProducerMQTransProducer Class: MQTransProducer MQTransProducer MQ的消息生产者，支持事务 new MQTransProducer(client, instanceId, topic, groupId) 构造函数 Parameters: Name Type Description client MQClient MQ的客户端 instanceId string 实例ID topic string 主题名字 groupId string 客户端GroupID Source: client.js, line 473 Returns: Type MQTransProducer Methods &lt;async&gt; commit(receiptHandle) 提交事务消息 Parameters: Name Type Description receiptHandle string consumeHalfMessage返回的单条消息句柄或者是发送事务消息返回的句柄 Source: client.js, line 658 Throws: err 请求失败或者其它网络异常 { // MQ服务端返回的错误Code，如ReceiptHandleError，表示消息句柄非法，MessageNotExist如果超过了TransCheckImmunityTime（针对发送事务消息的句柄）或者超过NextCnosumeTime Code: \"\" // 请求ID RequestId: \"\" } Type exception Returns: { // 请求成功 code:204, // 请求ID requestId:\"\" } Type object &lt;async&gt; consumeHalfMessage(numOfMessages, waitSeconds) 消费检查事务半消息,默认如果该条消息没有被 {commit} 或者 {rollback} 在NextConsumeTime时会再次消费到该条消息 Parameters: Name Type Description numOfMessages int 每次从服务端消费条消息 waitSeconds int 长轮询的等待时间（可空），如果服务端没有消息请求会在该时间之后返回等于请求阻塞在服务端，如果期间有消息立刻返回 Source: client.js, line 591 Throws: err MQ服务端返回的错误或者其它网络异常 { // MQ服务端返回的错误Code，其中MessageNotExist是正常现象，表示没有可消费的消息 Code: \"\", // 请求ID RequestId: \"\" } ```json Type exception Returns: { code: 200, requestId: \"\", body: [ { // 消息ID MessageId: \"\", // 消息体MD5 MessageBodyMD5: \"\", // 发送消息的时间戳，毫秒 PublishTime: {long}, // 下次重试消费的时间，前提是这次不调用{commit} 或者 {rollback}，毫秒 NextConsumeTime: {long}, // 第一次消费的时间，毫秒 FirstConsumeTime: {long}, // 消费的次数 ConsumedTimes: {long}, // 消息句柄，调用 {commit} 或者 {rollback} 需要将消息句柄传入，用于提交或者回滚该条事务消息 ReceiptHandle: \"\", // 消息内容 MessageBody: \"\", // 消息标签 MessageTag: \"\" } ] } Type object &lt;async&gt; publishMessage(body, tag, msgProps) 向主题发送一条消息 Parameters: Name Type Description body string 发送的内容 tag string 发送消息的标签 msgProps MessageProperties 发送消息的属性 Source: client.js, line 526 Throws: err MQ服务端返回的错误或者其它网络异常 { // MQ服务端返回的错误Code，like: TopicNotExist Code:\"\", // 请求ID RequestId:\"\" } Type exception Returns: { // http请求状态码，发送成功就是201，如果发送失败则抛异常 code: 201, // 请求ID requestId: \"xxxxxxxxxxxxxx\", // 发送消息的响应内容 body: { // 消息ID MessageId: \"\", // 消息体内容的MD5值 MessageBodyMD5: \"\" // 消息句柄，仅事务消息存在 ReceiptHandle: \"\" } } Type object &lt;async&gt; rollback(receiptHandle) 回滚事务消息 Parameters: Name Type Description receiptHandle string consumeHalfMessage返回的单条消息句柄或者是发送事务消息返回的句柄 Source: client.js, line 695 Throws: err 请求失败或者其它网络异常 { // MQ服务端返回的错误Code，如ReceiptHandleError，表示消息句柄非法，MessageNotExist如果超过了TransCheckImmunityTime（针对发送事务消息的句柄）或者超过NextCnosumeTime Code: \"\" // 请求ID RequestId: \"\" } Type exception Returns: { // 请求成功 code:204, // 请求ID requestId:\"\" } Type object × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
